package tools

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/tekierz/dotfiles/internal/pkg"
)

// NeovimConfig holds Neovim configuration settings
type NeovimConfig struct {
	ConfigPreset string   // "kickstart", "lazyvim", "custom", "minimal"
	LSPs         []string // LSP servers to configure
	Plugins      []string // Plugins to enable
	TabWidth     int
	Wrap         bool
	CursorLine   bool
	Clipboard    string // "unnamedplus", "unnamed", "none"
}

// NeovimTool represents the Neovim editor
type NeovimTool struct {
	BaseTool
}

// NewNeovimTool creates a new Neovim tool
func NewNeovimTool() *NeovimTool {
	home, _ := os.UserHomeDir()
	return &NeovimTool{
		BaseTool: BaseTool{
			id:          "neovim",
			name:        "Neovim",
			description: "Hyperextensible Vim-based text editor",
			icon:        "",
			category:    CategoryEditor,
			packages: map[pkg.Platform][]string{
				pkg.PlatformMacOS:  {"neovim"},
				pkg.PlatformArch:   {"neovim"},
				pkg.PlatformDebian: {"neovim"},
			},
			configPaths: []string{
				filepath.Join(home, ".config", "nvim", "init.lua"),
			},
			// UI metadata
			uiGroup:        UIGroupNone,
			configScreen:   12, // ScreenConfigNeovim
			defaultEnabled: true,
		},
	}
}

// neovimConfigRepos maps preset names to their git repositories
var neovimConfigRepos = map[string]string{
	"kickstart": "https://github.com/nvim-lua/kickstart.nvim.git",
	"lazyvim":   "https://github.com/LazyVim/starter.git",
}

// GenerateNeovimConfig builds basic neovim settings as a Lua string.
// For preset configs (kickstart, lazyvim), this generates a user preferences file.
func GenerateNeovimConfig(cfg NeovimConfig, theme string) string {
	var sb strings.Builder

	// Header
	sb.WriteString("-- Generated by dotfiles TUI\n")
	sb.WriteString(fmt.Sprintf("-- Theme: %s\n\n", theme))

	// Basic settings
	sb.WriteString("-- Basic settings\n")
	sb.WriteString("vim.opt.number = true\n")
	sb.WriteString("vim.opt.relativenumber = true\n")
	sb.WriteString(fmt.Sprintf("vim.opt.tabstop = %d\n", cfg.TabWidth))
	sb.WriteString(fmt.Sprintf("vim.opt.shiftwidth = %d\n", cfg.TabWidth))
	sb.WriteString("vim.opt.expandtab = true\n")
	sb.WriteString(fmt.Sprintf("vim.opt.wrap = %t\n", cfg.Wrap))
	sb.WriteString(fmt.Sprintf("vim.opt.cursorline = %t\n", cfg.CursorLine))
	sb.WriteString("\n")

	// Clipboard
	sb.WriteString("-- Clipboard\n")
	if cfg.Clipboard != "none" {
		sb.WriteString(fmt.Sprintf("vim.opt.clipboard = \"%s\"\n", cfg.Clipboard))
	}
	sb.WriteString("\n")

	// Search settings
	sb.WriteString("-- Search\n")
	sb.WriteString("vim.opt.ignorecase = true\n")
	sb.WriteString("vim.opt.smartcase = true\n")
	sb.WriteString("vim.opt.hlsearch = true\n")
	sb.WriteString("vim.opt.incsearch = true\n\n")

	// UI settings
	sb.WriteString("-- UI\n")
	sb.WriteString("vim.opt.termguicolors = true\n")
	sb.WriteString("vim.opt.signcolumn = \"yes\"\n")
	sb.WriteString("vim.opt.scrolloff = 8\n")
	sb.WriteString("vim.opt.sidescrolloff = 8\n\n")

	// Performance
	sb.WriteString("-- Performance\n")
	sb.WriteString("vim.opt.updatetime = 250\n")
	sb.WriteString("vim.opt.timeoutlen = 300\n\n")

	// Leader key
	sb.WriteString("-- Leader\n")
	sb.WriteString("vim.g.mapleader = \" \"\n")
	sb.WriteString("vim.g.maplocalleader = \" \"\n")

	return sb.String()
}

// WriteNeovimConfig writes the neovim configuration to disk
func WriteNeovimConfig(cfg NeovimConfig, theme string) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	nvimDir := filepath.Join(home, ".config", "nvim")

	// Handle preset configurations
	switch cfg.ConfigPreset {
	case "kickstart", "lazyvim":
		return setupNeovimPreset(cfg, theme, nvimDir)
	default:
		// For minimal/custom, just write the basic init.lua
		return writeMinimalNeovimConfig(cfg, theme, nvimDir)
	}
}

// setupNeovimPreset clones a preset config and adds user customizations
func setupNeovimPreset(cfg NeovimConfig, theme, nvimDir string) error {
	repoURL, ok := neovimConfigRepos[cfg.ConfigPreset]
	if !ok {
		return writeMinimalNeovimConfig(cfg, theme, nvimDir)
	}

	// Check if config already exists
	initFile := filepath.Join(nvimDir, "init.lua")
	if _, err := os.Stat(initFile); err == nil {
		// Config exists, just update user preferences
		return writeNeovimUserPrefs(cfg, theme, nvimDir)
	}

	// Backup existing config if present
	if _, err := os.Stat(nvimDir); err == nil {
		backupDir := nvimDir + ".backup"
		_ = os.RemoveAll(backupDir)
		_ = os.Rename(nvimDir, backupDir)
	}

	// Clone the preset
	cmd := exec.Command("git", "clone", "--depth", "1", repoURL, nvimDir)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to clone %s config: %w", cfg.ConfigPreset, err)
	}

	// Remove .git directory to make it user-owned
	gitDir := filepath.Join(nvimDir, ".git")
	_ = os.RemoveAll(gitDir)

	// Write user preferences
	return writeNeovimUserPrefs(cfg, theme, nvimDir)
}

// writeNeovimUserPrefs writes user preferences to a separate file
func writeNeovimUserPrefs(cfg NeovimConfig, theme, nvimDir string) error {
	luaDir := filepath.Join(nvimDir, "lua", "custom")
	if err := os.MkdirAll(luaDir, 0700); err != nil {
		return fmt.Errorf("failed to create lua/custom directory: %w", err)
	}

	prefsPath := filepath.Join(luaDir, "options.lua")
	content := GenerateNeovimConfig(cfg, theme)

	if err := os.WriteFile(prefsPath, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write user preferences: %w", err)
	}

	// Add require to init.lua if not already present
	initPath := filepath.Join(nvimDir, "init.lua")
	initContent, err := os.ReadFile(initPath)
	if err == nil {
		requireLine := "pcall(require, \"custom.options\")"
		if !strings.Contains(string(initContent), requireLine) {
			// Append at the end
			newContent := string(initContent) + "\n\n-- User options from dotfiles\n" + requireLine + "\n"
			_ = os.WriteFile(initPath, []byte(newContent), 0600)
		}
	}

	return nil
}

// writeMinimalNeovimConfig writes a minimal standalone neovim config
func writeMinimalNeovimConfig(cfg NeovimConfig, theme, nvimDir string) error {
	if err := os.MkdirAll(nvimDir, 0700); err != nil {
		return fmt.Errorf("failed to create nvim config directory: %w", err)
	}

	initPath := filepath.Join(nvimDir, "init.lua")
	content := GenerateNeovimConfig(cfg, theme)

	if err := os.WriteFile(initPath, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write init.lua: %w", err)
	}

	return nil
}

// GenerateConfig implements Tool interface (uses defaults)
func (t *NeovimTool) GenerateConfig(theme string) string {
	cfg := NeovimConfig{
		ConfigPreset: "kickstart",
		LSPs:         []string{"lua_ls", "pyright", "tsserver", "gopls"},
		Plugins:      []string{"telescope", "treesitter", "lsp", "cmp"},
		TabWidth:     4,
		Wrap:         false,
		CursorLine:   true,
		Clipboard:    "unnamedplus",
	}
	return GenerateNeovimConfig(cfg, theme)
}

// ApplyConfig implements Tool interface (uses defaults)
func (t *NeovimTool) ApplyConfig(theme string) error {
	cfg := NeovimConfig{
		ConfigPreset: "kickstart",
		LSPs:         []string{"lua_ls", "pyright", "tsserver", "gopls"},
		Plugins:      []string{"telescope", "treesitter", "lsp", "cmp"},
		TabWidth:     4,
		Wrap:         false,
		CursorLine:   true,
		Clipboard:    "unnamedplus",
	}
	return WriteNeovimConfig(cfg, theme)
}
