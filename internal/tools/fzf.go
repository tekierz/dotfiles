package tools

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/tekierz/dotfiles/internal/pkg"
)

// FzfConfig holds FZF configuration settings
type FzfConfig struct {
	Preview bool
	Height  int    // Percentage (e.g., 40 for 40%)
	Layout  string // "reverse", "default", "reverse-list"
}

// FzfTool represents the fzf fuzzy finder
type FzfTool struct {
	BaseTool
}

// NewFzfTool creates a new fzf tool
func NewFzfTool() *FzfTool {
	return &FzfTool{
		BaseTool: BaseTool{
			id:          "fzf",
			name:        "fzf",
			description: "Command-line fuzzy finder",
			icon:        "ó°‰",
			category:    CategoryUtility,
			packages: map[pkg.Platform][]string{
				pkg.PlatformMacOS:  {"fzf"},
				pkg.PlatformArch:   {"fzf"},
				pkg.PlatformDebian: {"fzf"},
			},
			configPaths: []string{},
			// UI metadata
			uiGroup:        UIGroupNone,
			configScreen:   15, // ScreenConfigFzf
			defaultEnabled: true,
		},
	}
}

// GenerateFzfConfig builds the fzf environment configuration
func GenerateFzfConfig(cfg FzfConfig, theme string) string {
	var sb strings.Builder

	// Header
	sb.WriteString("# Generated by dotfiles TUI\n")
	sb.WriteString(fmt.Sprintf("# Theme: %s\n\n", theme))

	// Build FZF_DEFAULT_OPTS
	var opts []string

	// Layout
	if cfg.Layout != "" && cfg.Layout != "default" {
		opts = append(opts, fmt.Sprintf("--layout=%s", cfg.Layout))
	}

	// Height
	if cfg.Height > 0 && cfg.Height < 100 {
		opts = append(opts, fmt.Sprintf("--height=%d%%", cfg.Height))
	}

	// Preview
	if cfg.Preview {
		opts = append(opts, "--preview 'bat --style=numbers --color=always --line-range :500 {} 2>/dev/null || cat {}'")
		opts = append(opts, "--preview-window=right:50%:wrap")
	}

	// Common styling
	opts = append(opts, "--border=rounded")
	opts = append(opts, "--margin=1")
	opts = append(opts, "--padding=1")

	// Write export
	if len(opts) > 0 {
		sb.WriteString("export FZF_DEFAULT_OPTS=\"\\\n")
		for i, opt := range opts {
			if i < len(opts)-1 {
				sb.WriteString(fmt.Sprintf("  %s \\\n", opt))
			} else {
				sb.WriteString(fmt.Sprintf("  %s\"\n", opt))
			}
		}
	}
	sb.WriteString("\n")

	// FZF_DEFAULT_COMMAND (use fd if available)
	sb.WriteString("# Use fd if available for faster searching\n")
	sb.WriteString("if command -v fd &>/dev/null; then\n")
	sb.WriteString("  export FZF_DEFAULT_COMMAND='fd --type f --strip-cwd-prefix --hidden --follow --exclude .git'\n")
	sb.WriteString("  export FZF_CTRL_T_COMMAND=\"$FZF_DEFAULT_COMMAND\"\n")
	sb.WriteString("  export FZF_ALT_C_COMMAND='fd --type d --strip-cwd-prefix --hidden --follow --exclude .git'\n")
	sb.WriteString("fi\n\n")

	// Key bindings
	sb.WriteString("# Enable fzf key bindings and completion\n")
	sb.WriteString("if [[ -f /usr/share/fzf/key-bindings.zsh ]]; then\n")
	sb.WriteString("  source /usr/share/fzf/key-bindings.zsh\n")
	sb.WriteString("  source /usr/share/fzf/completion.zsh\n")
	sb.WriteString("elif [[ -f ~/.fzf.zsh ]]; then\n")
	sb.WriteString("  source ~/.fzf.zsh\n")
	sb.WriteString("elif command -v brew &>/dev/null; then\n")
	sb.WriteString("  [[ -f $(brew --prefix)/opt/fzf/shell/key-bindings.zsh ]] && source $(brew --prefix)/opt/fzf/shell/key-bindings.zsh\n")
	sb.WriteString("  [[ -f $(brew --prefix)/opt/fzf/shell/completion.zsh ]] && source $(brew --prefix)/opt/fzf/shell/completion.zsh\n")
	sb.WriteString("fi\n")

	return sb.String()
}

// WriteFzfConfig writes the fzf configuration to a sourceable file
func WriteFzfConfig(cfg FzfConfig, theme string) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	configDir := filepath.Join(home, ".config", "fzf")
	if err := os.MkdirAll(configDir, 0700); err != nil {
		return fmt.Errorf("failed to create fzf config directory: %w", err)
	}

	configPath := filepath.Join(configDir, "fzf.zsh")
	content := GenerateFzfConfig(cfg, theme)

	if err := os.WriteFile(configPath, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write fzf config: %w", err)
	}

	return nil
}

// GenerateConfig implements Tool interface (uses defaults)
func (t *FzfTool) GenerateConfig(theme string) string {
	cfg := FzfConfig{
		Preview: true,
		Height:  40,
		Layout:  "reverse",
	}
	return GenerateFzfConfig(cfg, theme)
}

// ApplyConfig implements Tool interface (uses defaults)
func (t *FzfTool) ApplyConfig(theme string) error {
	cfg := FzfConfig{
		Preview: true,
		Height:  40,
		Layout:  "reverse",
	}
	return WriteFzfConfig(cfg, theme)
}
